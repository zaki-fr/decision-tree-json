import _typeof from '@babel/runtime/helpers/typeof';
import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import _createClass from '@babel/runtime/helpers/createClass';
import BaseError from '@ianwalter/base-error';

function findItemByKey() {
  var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var key = arguments.length > 1 ? arguments[1] : undefined;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var item = _step.value;

      if (item.key === key) {
        return item;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

var _default =
/*#__PURE__*/
function () {
  function _default() {
    var tree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [tree];
    var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, _default);

    this.path = path;
    this.state = state;
    this.noChildren = "No children found to move to";
    this.noLead = "Can't determine which child to move to";
    this.noParent = "No parent node found to move to";
  }

  _createClass(_default, [{
    key: "set",
    value: function set(key, value) {
      if (_typeof(key) === 'object' && value === undefined) {
        this.state = key;
      } else {
        this.state[key] = value;
      }

      return this;
    }
  }, {
    key: "current",
    value: function current() {
      return this.path[this.path.length - 1];
    }
  }, {
    key: "goToNode",
    value: function goToNode(node) {
      return node ? this.path.push(node) && node : node;
    }
  }, {
    key: "getNodeFromLeadsTo",
    value: function getNodeFromLeadsTo(currentNode, _ref) {
      var leadsTo = _ref.leadsTo;
      var key = typeof leadsTo === 'function' ? leadsTo(this) : leadsTo;
      return findItemByKey(currentNode.children, key);
    }
  }, {
    key: "next",
    value: function next() {
      var currentNode = this.current(); // Get the selected option key from state or extract it from an array if
      // multiple options can be selected.

      var selectedOptionKey = this.state[currentNode.key];

      if (Array.isArray(selectedOptionKey) && selectedOptionKey.length === 1) {
        selectedOptionKey = selectedOptionKey[0];
      } // Find the selected option object by it's key.


      var selectedOption = findItemByKey(currentNode.options, selectedOptionKey); // Move to the next node.

      if (currentNode.children.length < 1) {
        // No children to move to!
        throw new BaseError(this.noChildren, currentNode);
      } else if (currentNode.children.length === 1) {
        // Move to the only child.
        return this.goToNode(currentNode.children[0]);
      } else if (selectedOption && selectedOption.leadsTo) {
        // Move to what the single selected option tells us to move to.
        return this.goToNode(this.getNodeFromLeadsTo(currentNode, selectedOption));
      } else if (currentNode.leadsTo) {
        // Move to what the currentNode tells us to move to (maybe there are
        // multiple options selected).
        return this.goToNode(this.getNodeFromLeadsTo(currentNode, currentNode));
      } // Throw an error if the next node to move to can't be determined.


      throw new BaseError(this.noLead, selectedOptionKey, selectedOption);
    }
  }, {
    key: "prev",
    value: function prev() {
      var parentNode = this.path[this.path.length - 2];

      if (parentNode) {
        return this.path.pop();
      }

      throw new BaseError(this.noParent);
    }
  }, {
    key: "pathKeys",
    value: function pathKeys() {
      return this.path.map(function (_ref2) {
        var key = _ref2.key;
        return key;
      });
    }
  }]);

  return _default;
}();

export default _default;
